<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_10) on Mon Mar 09 18:13:43 PDT 2009 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Recognizer (JSAPI 2.0, Final Release v2.0.6)
</TITLE>

<META NAME="date" CONTENT="2009-03-09">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Recognizer (JSAPI 2.0, Final Release v2.0.6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Recognizer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>JSAPI 2.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/speech/recognition/RecognizerEvent.html" title="class in javax.speech.recognition"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/speech/recognition/Recognizer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Recognizer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.speech.recognition</FONT>
<BR>
Interface Recognizer</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Recognizer</B><DT>extends <A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></DL>
</PRE>

<P>
Provides access to speech recognition capabilities.

 The <code>Recognizer</code> interface extends the
 <A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech"><CODE>Engine</CODE></A> interface and
 so inherits the basic <code>Engine</code> capabilities and provides additional
 specialized capabilities.
 <p>
 The primary capabilities provided are <code>Recognizer</code> control 
 and <code>Result</code> handling.
 An application is responsible for providing a <code>Recognizer</code> with 
 <code>Grammar</code>s through the <A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition"><CODE>GrammarManager</CODE></A>.
 A <A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A> defines a set of words (technically known as tokens)
 and defines acceptable patterns in which the tokens may be spoken.
 When a <code>Grammar</code> is <i>active</i>, 
 the <code>Recognizer</code> listens for speech in the
 incoming audio that matches the <code>Grammar</code>.
 When speech is detected, the <code>Recognizer</code> produces a <A HREF="../../../javax/speech/recognition/Result.html" title="interface in javax.speech.recognition"><CODE>Result</CODE></A>.
 The <code>Result</code> object is passed to the application with information
 on which words were heard.
 <p>
 The types of <code>Grammar</code>s, mechanisms for creating, modifying and
 managing <code>Grammar</code>s, types of <code>Result</code>s, 
 <code>Result</code> handling and other <code>Recognizer</code>
 functions are described in more detail below.

 <h3>Creating a Recognizer</h3>

 A <code>Recognizer</code> is created by a call to the
 <A HREF="../../../javax/speech/EngineManager.html#createEngine(javax.speech.EngineMode)"><CODE>createEngine</CODE></A> method
 of the <A HREF="../../../javax/speech/EngineManager.html" title="class in javax.speech"><CODE>EngineManager</CODE></A> class.
 A <code>Recognizer</code> for the default <code>SpeechLocale</code> is created as follows:
 <blockquote><code><pre>
 Recognizer rec = (Recognizer)
     EngineManager.createEngine(RecognizerMode.DEFAULT);
 </pre></code></blockquote>
 The <code>recognition</code> package overview contains a
 <a href="package-summary.html#example-HelloRecognition">
 recognition example
 </a>.
 Detailed descriptions of the procedures for locating,
 selecting, creating and initializing a Recognizer are provided in the
 documentation for the
 <A HREF="../../../javax/speech/EngineManager.html" title="class in javax.speech"><CODE>EngineManager</CODE></A>.

 <a name="Section-Using_Grammars"></a>
 <h3>Using Grammars</h3>

 The <code>GrammarManager</code> provides the functionality to create and
 manipulate <code>Grammar</code>s used by the <code>Recognizer</code>.
 The <code>Recognizer</code> must be provided with one or more <code>Grammar</code>s 
 that indicate what words and word sequences it should recognize.
 The basic process for dealing with a Grammar follows.
 <ol>
 <li> <code>pause</code> the <code>Recognizer</code> (if not already <code>PAUSED</code>)
 <li> As necessary, create or modify <code>Grammar</code>s according to
      the application context.
 <li> Enable (default) and disable <code>Grammar</code>s for recognition as needed.
 <li> Attach a <code>ResultListener</code> to either the <code>Recognizer</code> or
      <code>Grammar</code> to receive <code>ResultEvent</code>s.
 <li> <code>resume</code> the <code>Recognizer</code> to atomically commit 
      any <code>Grammar</code> changes.
 <li> Repeat steps 1 through 5 as required.
 <li> Delete application-created <code>Grammar</code>s when 
      they are no longer needed.
 </ol>

 <h3>Efficiency</h3>

 The processing of <code>Grammar</code>s (particularly large <code>Grammar</code>s)
 can be computationally expensive.
 Loading a new <code>Grammar</code> can take appreciable time.
 Updates to a <code>Grammar</code> may also be slow.
 Therefore, applications should take precautions to build <code>Grammar</code>s in
 advance and to modify them only when necessary.
 Furthermore, an application should minimize the number of <code>Grammar</code>s 
 active at any point in time.

 <h3>Recognizer States</h3>

 A <code>Recognizer</code> inherits two pairs of substates from the
 <A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A> state from the <code>Engine</code> interface:
 <ul>
 <li> <A HREF="../../../javax/speech/Engine.html#FOCUSED"><CODE>FOCUSED</CODE></A> and <A HREF="../../../javax/speech/Engine.html#DEFOCUSED"><CODE>DEFOCUSED</CODE></A>
 <li> <A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A> and <A HREF="../../../javax/speech/Engine.html#RESUMED"><CODE>RESUMED</CODE></A>
 </ul>
 The initial states are <code>DEFOCUSED</code> and <code>PAUSED</code>.
 An application should call
 <A HREF="../../../javax/speech/recognition/Recognizer.html#requestFocus()"><CODE>requestFocus</CODE></A> and
 <A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A> after loading <code>Grammar</code>s.
 <p>
 The <code>Recognizer</code> interface adds two substates to the <code>RESUMED</code>
 state:
 <ul>
 <li> <A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A> and <A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING"><CODE>PROCESSING</CODE></A>
 </ul>
 When <code>RESUMED</code>, the initial state is <code>LISTENING</code> while the 
 <code>Recognizer</code> listens for speech.
 Once speech is found, the <code>Recognizer</code> remains in the 
 <code>PROCESSING</code> state until it produces a <code>Result</code>.
 <p>
 See the
 <a href="../../../doc-files/diagrams/Diagrams.html">Table of Diagrams</a>
 for state transition diagrams.

 <a name="Section-focus_policy"></a>
 <h3>Recognizer States: Focus Policy</h3>

 A <code>Recognizer</code> uses a two state substate-system with <code>FOCUSED</code>
 and <code>DEFOCUSED</code> to indicate whether this instance of the
 <code>Recognizer</code> currently has the recognition focus.
 Focus is important in an environment with multiple applications
 because more than one application can share an
 underlying speech recognition engine, but the user gives recognition focus
 to only one application at a time.
 Since it is normal for an application to use only one <code>Recognizer</code>,
 recognition focus and application focus normally mean the same thing.
 (Applications with multiple <code>Recognizer</code>s cannot make this assumption.)
 <p>
 Focus is not usually relevant in telephony applications or some
 embedded applications in which there is a single input audio stream
 to a single application.
 <p>
 The focus status is a key factor in determining the activation
 of <code>Grammar</code>s and therefore in determining when <code>Result</code>s will
 and will not be generated.
 The 
 <a href="Grammar.html#Section-GrammarActivation">activation conditions</a>
 for <code>Grammar</code>s and the role of focus are
 described in the <A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A> interface.
 <p>
 When focus is received, an <code>ENGINE_FOCUSED</code> event
 is issued to any <code>RecognizerListener</code>s attached to this <code>Engine</code>.
 When focus is released or otherwise lost,
 an <code>ENGINE_DEFOCUSED</code> event is issued
 to any <code>RecognizerListener</code>s attached to this <code>Engine</code>.
 <p>
 Applications can request focus for the <code>Recognizer</code> by calling
 the <A HREF="../../../javax/speech/recognition/Recognizer.html#requestFocus()"><CODE>requestFocus</CODE></A> method.
 This asynchronous method may return before focus is received.
 To determine when focus is on,
 applications can check for <code>ENGINE_FOCUSED</code> events or
 test the <code>FOCUSED</code> bit of <code>Engine</code> state.
 <p>
 Applications can release focus from the <code>Recognizer</code> by calling
 the <A HREF="../../../javax/speech/recognition/Recognizer.html#releaseFocus()"><CODE>releaseFocus</CODE></A> method.
 This asynchronous method may return before focus is lost.
 To determine when focus is off,
 applications can check for <code>ENGINE_DEFOCUSED</code> events or test
 the <code>DEFOCUSED</code> bit of <code>Engine</code> state.
 In GUI-based environments, it is normal (but not required)
 for recognition focus to follow GUI focus.
 Therefore, for example, it is common for the <code>requestFocus</code> method
 to be called
 on AWT or Swing events such as <code>FocusEvent</code> and <code>WindowEvent</code>
 or in association with a MIDlet's <code>startApp</code> method.
 <p>
 A well-behaved application only requests focus when it knows that it has
 the focus of the user (the user is talking to it and not to
 other applications).
 A well-behaved application will also release focus as soon as it
 finishes with it.

 <a name="Section-TypicalEventCycle"></a>
 <h3>Recognizer States: RESUMED - Typical Event Cycle</h3>

 The typical state cycle for <code>RESUMED</code> follows.
 This assumes that <code>Grammar</code>s have been defined as described above and
 committed with a call to <code>resume</code>.
 The call to <code>resume</code> transitions the <code>Recognizer</code> from the
 <code>PAUSED</code> state to the <code>RESUMED</code> state preceded by the events
 <code>CHANGES_COMMITTED</code>/<code>CHANGES_REJECTED</code>,
 <code>ENGINE_RESUMED</code>, and
 <code>RECOGNIZER_LISTENING</code>.
 <ol>
 <li> A <code>Recognizer</code> starts in the <code>LISTENING</code> state with a
      certain set of 
      <a href="Grammar.html#Section-GrammarActivation">active</a>
      <code>Grammar</code>s.
      When incoming audio is detected that may match an active 
      <code>Grammar</code>, the <code>Recognizer</code> transitions to the 
      <code>PROCESSING</code> state with a <code>RECOGNIZER_PROCESSING</code>
      <code>RecognizerEvent</code>.
      The <code>Recognizer</code> then creates a new <code>Result</code> and issues a
      <code>RESULT_CREATED</code>
      <code>ResultEvent</code> to provide the <code>Result</code> to the application.
      </li>
 <li> The <code>Recognizer</code> remains in the <code>PROCESSING</code> state until
      it completes recognition of the <code>Result</code>.
      </li>
 <li> The <code>Recognizer</code> indicates completion of recognition by issuing
      an <code>ENGINE_PAUSED</code> <code>EngineEvent</code> to transition from the
      <code>PROCESSING</code> substate to the <code>PAUSED</code> state.
      Once in that state, it issues a <code>Result</code> finalization 
      <code>ResultEvent</code> to <code>ResultListener</code>s 
      (<code>RESULT_ACCEPTED</code> or <code>RESULT_REJECTED</code>).
      </li>
 <li> The <code>Recognizer</code> remains in the <code>PAUSED</code> state until 
      processing of the <code>Result</code> finalization <code>ResultEvent</code>
      is completed.
      Applications will usually make any necessary <code>Grammar</code> changes
      while the <code>Recognizer</code> is <code>PAUSED</code>.
      The <code>Recognizer</code> buffers incoming audio 
      in this scenario.
      Buffering allows a user to continue speaking without loss of
      speech data.
      Once the <code>Recognizer</code> returns to the <code>RESUMED</code> state and
      <code>LISTENING</code> substate, any buffered audio
      is processed to give the user the perception of real-time processing.
      </li>
 <li> The <code>Recognizer</code>
      <a href="Grammar.html#Section-commit">
      commits all <code>Grammar</code> changes</a>,
      issues <code>CHANGES_COMMITTED</code>/<code>CHANGES_REJECTED</code> and 
      <code>ENGINE_RESUMED</code> events to any <code>RecognizerListener</code>s 
      and returns to the <code>RESUMED</code>/<code>LISTENING</code> state/substate.
      It also issues
      <code>GRAMMAR_CHANGES_COMMITTED</code>/<code>GRAMMAR_CHANGES_REJECTED</code>
      <code>GrammarEvent</code>s to <code>GrammarListener</code>s of
      changed <code>Grammar</code>s.
      The <code>Grammar</code> commit applies all <code>Grammar</code> changes made
      at any point up to the end of <code>Result</code> finalization,
      typically including changes made in the
      <code>Result</code> finalization <code>ResultEvent</code>s.
      </li>
 <li> The <code>Recognizer</code> listens in the <code>LISTENING</code> state for speech
      that matches the updated <code>Grammar</code>s.
      </li>
 </ol>
 In this state cycle, the <code>RECOGNIZER_PROCESSING</code>
 <code>RecognizerEvent</code> is triggered by user action: 
 starting and stopping speaking.
 The <code>ENGINE_PAUSED</code> and <code>ENGINE_RESUMED</code> EngineEvents are
 triggered programmatically by the <code>Recognizer</code> after issuing events to
 application listeners during <code>Result</code> finalization.

 <a name="Section-NonSpeechEvents"></a>
 <h3> Recognizer States: RESUMED - Non-Speech Events </h3>

 For applications that deal only with spoken input, the state cycle above
 handles most normal speech interactions.
 For applications that handle other asynchronous input,
 additional state transitions are possible.
 Other types of asynchronous input include graphical user interface events,
 timer events, multi-threading events, socket events, etc.
 <p>
 When a non-speech event occurs that changes the application state
 or application data,
 it is often necessary to update the <code>Recognizer</code>'s <code>Grammar</code>s.
 Furthermore, it is typically necessary to do this as if the change occurred
 in real time - at exactly the point in time at which the event occurred.
 <p>
 The <code>pause</code> and <code>resume</code> methods of a <code>Recognizer</code> 
 may be used to handle non-speech asynchronous events.
 The typical cycle for updating <code>Grammar</code>s is as follows:
 <ol>
 <li> Assume that the <code>Recognizer</code> is in the <code>LISTENING</code> state
      (the user is not currently speaking).
      As soon as the non-speech event is received, the application calls
      <code>pause(BUFFER_MODE)</code> to indicate that it is 
      about to change <code>Grammar</code>s.
 <li> The recognizer issues a <code>RECOGNIZER_PAUSED</code>
      <code>RecognizerEvent</code> and transitions
      from the <code>LISTENING</code> substate to the <code>PAUSED</code> state.
 <li> The application makes all necessary changes to the <code>Grammar</code>s.
 <li> Once all changes are completed, the application calls the
      <code>resume</code> method.
      The <code>Recognizer</code> commits the <code>Grammar</code> updates atomically,
      issues a <code>CHANGES_COMMITTED</code>/<code>CHANGES_REJECTED</code> 
      <code>RecognizerEvent</code> to transition from the <code>PAUSED</code> state 
      back to the <code>RESUMED</code> state and <code>LISTENING</code> substate,
      and issues 
      <code>GRAMMAR_CHANGES_COMMITTED</code>/<code>GRAMMAR_CHANGES_REJECTED</code> 
      <code>GrammarEvent</code>s to all changed <code>Grammar</code>s.
 <li> The <code>Recognizer</code> resumes recognition of any buffered audio and
      then live audio with the updated <code>Grammar</code>s.
 </ol>
 Because audio is buffered from the time of the asynchronous non-speech event
 to the time at which the <code>CHANGES_COMMITTED</code>/<code>CHANGES_REJECTED</code> 
 <code>RecognizerEvent</code> occurs,
 the audio is processed as if the updated <code>Grammar</code>s were applied exactly at
 the time of the asynchronous non-speech event.
 The user has the perception of real-time processing.
 <p>
 Although audio is buffered in the <code>PAUSED</code> state with
 <code>pause(BUFFER_MODE)</code>,
 applications should makes changes and <code>resume</code> as quickly as possible.
 This minimizes the possibility of a buffer overrun (NOT_BUFFERING).
 It also reduces delays in recognizing speech and responding to the user.
 <p>
 <!-- Should there be a recognizer.cancel() for the current result? -->
 <!-- Is forceFinalize() sufficient? -->

 <h3>Recognizer States: RESUMED - Mixing Speech and Non-Speech Events</h3>

 There is no guarantee that speech and non-speech events will not be mixed.
 If a speech event occurs in the absence of non-speech events, the
 <a href="#Section-TypicalEventCycle">normal event cycle</a>
 takes place.
 If a non-speech event occurs in the absence of any speech events, the
 <a href="#Section-NonSpeechEvents">non-speech event cycle</a>
 takes place.
 <p>
 Consider the two cases in which speech and non-speech events interact:
 <ol>
 <li>
 A non-speech event occurs during processing of a speech event:<br>
 Technically, this is the case in which a non-speech event is issued
 while the <code>Recognizer</code> is in either the
 <code>PROCESSING</code> substate or the <code>PAUSED</code> state.
 In both cases the event processing for the non-speech is no different
 than normal. 
 The non-speech event handler calls <code>pause(BUFFER_MODE)</code> to indicate it
 is about to change <code>Grammar</code>s, makes the <code>Grammar</code> changes, 
 and then calls <code>resume</code> to apply the commit the changes atomically.
 <p>
 The effect is that the 
 <code>CHANGES_COMMITTED</code>/<code>CHANGES_REJECTED</code> 
 <code>RecognizerEvent</code> that would occur in the
 <a href="#Section-TypicalEventCycle">normal event cycle</a>
 may be delayed until the <code>resume</code> method
 is explicitly called and <code>Result</code> finalization completes.
 At that point, the <code>Recognizer</code> applies changes made in response
 to both the speech and non-speech events.
 <li>
 A speech event occurs during processing of a non-speech event:<br>
 This case is simpler. 
 If the user starts speaking while a non-speech event is being processed,
 then the <code>Recognizer</code> is in the <code>PAUSED</code> state,
 speech is buffered, and the speech event is actually delayed until
 the <code>Recognizer</code> returns to the <code>LISTENING</code> substate.
 Once the <code>Recognizer</code> returns to the <code>LISTENING</code> substate, 
 the incoming speech is processed with the
 <a href="#Section-TypicalEventCycle">normal event cycle</a>.
 </ol>
 
 <a name="Section-Conditions_for_Operation"></a>
 <h3>Conditions for Operation</h3>
 
 Where noted, standard Conditions for Operation apply.
 This means that a method operates as defined only when the 
 <code>Engine</code> is in the <code>ALLOCATED</code> state
 and not <code>DEALLOCATING_RESOURCES</code>. 
 The call blocks if the <code>Engine</code> is in the
 <code>ALLOCATING_RESOURCES</code> state and completes when the <code>Engine</code>
 reaches the <code>ALLOCATED</code> state. 
 Otherwise, an exception is thrown for an <code>Engine</code> 
 in the <code>DEALLOCATING_RESOURCES</code> or <code>DEALLOCATED</code> states.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/EngineManager.html" title="class in javax.speech"><CODE>EngineManager</CODE></A>, 
<A HREF="../../../javax/speech/EngineManager.html#createEngine(javax.speech.EngineMode)"><CODE>createEngine</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html" title="class in javax.speech.recognition"><CODE>RecognizerEvent</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition"><CODE>RecognizerListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RuleGrammar.html" title="interface in javax.speech.recognition"><CODE>RuleGrammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition"><CODE>GrammarManager</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Result.html" title="interface in javax.speech.recognition"><CODE>Result</CODE></A>, 
<A HREF="../../../javax/speech/recognition/FinalResult.html" title="interface in javax.speech.recognition"><CODE>FinalResult</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#BUFFER_MODE">BUFFER_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag used to indicate that audio buffering 
 should continue while <code>PAUSED</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#BUFFERING">BUFFERING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is buffering audio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING">LISTENING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is listening to incoming audio for speech that may match an active
 <code>Grammar</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#NOT_BUFFERING">NOT_BUFFERING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is not buffering audio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING">PROCESSING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is producing a <code>Result</code> for incoming speech that may match
 an active <code>Grammar</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_Engine"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface <A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/speech/Engine.html#ALLOCATED">ALLOCATED</A>, <A HREF="../../../javax/speech/Engine.html#ALLOCATING_RESOURCES">ALLOCATING_RESOURCES</A>, <A HREF="../../../javax/speech/Engine.html#ASYNCHRONOUS_MODE">ASYNCHRONOUS_MODE</A>, <A HREF="../../../javax/speech/Engine.html#DEALLOCATED">DEALLOCATED</A>, <A HREF="../../../javax/speech/Engine.html#DEALLOCATING_RESOURCES">DEALLOCATING_RESOURCES</A>, <A HREF="../../../javax/speech/Engine.html#DEFOCUSED">DEFOCUSED</A>, <A HREF="../../../javax/speech/Engine.html#ERROR_OCCURRED">ERROR_OCCURRED</A>, <A HREF="../../../javax/speech/Engine.html#FOCUSED">FOCUSED</A>, <A HREF="../../../javax/speech/Engine.html#IMMEDIATE_MODE">IMMEDIATE_MODE</A>, <A HREF="../../../javax/speech/Engine.html#PAUSED">PAUSED</A>, <A HREF="../../../javax/speech/Engine.html#RESUMED">RESUMED</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#addRecognizerListener(javax.speech.recognition.RecognizerListener)">addRecognizerListener</A></B>(<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition">RecognizerListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests notifications of <code>RecognizerEvent</code>s related to
 this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#addResultListener(javax.speech.recognition.ResultListener)">addResultListener</A></B>(<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition">ResultListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests notifications of all <code>ResultEvent</code>s for all
 <code>Result</code>s produced by this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#allocate()">allocate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates the resources required for this <code>Engine</code> and puts it into
 the <code>ALLOCATED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#allocate(int)">allocate</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates the resources required for this <code>Engine</code>
 using the <code>mode</code> specified
 and puts it into the <code>ALLOCATED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()">deallocate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deallocates the resources acquired for this <code>Engine</code>
 and returns it to the <code>DEALLOCATED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate(int)">deallocate</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deallocates the resources acquired for this <code>Engine</code>
 using the <code>mode</code> specified
 and returns it to the <code>DEALLOCATED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition">GrammarManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#getGrammarManager()">getGrammarManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>GrammarManager</code> for this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/speech/recognition/RecognizerProperties.html" title="interface in javax.speech.recognition">RecognizerProperties</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#getRecognizerProperties()">getRecognizerProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the properties for this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#getResultMask()">getResultMask</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the mask to filter <code>ResultEvent</code>s for added <code>ResultListener</code>s.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/speech/recognition/SpeakerManager.html" title="interface in javax.speech.recognition">SpeakerManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#getSpeakerManager()">getSpeakerManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>SpeakerManager</code> for this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#pause()">pause</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pauses the audio processing for this <code>Engine</code> and
 puts it into the <code>PAUSED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#pause(int)">pause</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pauses a <code>Recognizer</code> with additional options.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#processGrammars()">processGrammars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Informs this <code>Recognizer</code> that <code>Grammar</code>s have changed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#releaseFocus()">releaseFocus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases the recognition focus from this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#removeRecognizerListener(javax.speech.recognition.RecognizerListener)">removeRecognizerListener</A></B>(<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition">RecognizerListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a <code>RecognizerListener</code> from this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#removeResultListener(javax.speech.recognition.ResultListener)">removeResultListener</A></B>(<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition">ResultListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a <code>ResultListener</code> from this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#requestFocus()">requestFocus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests the recognition focus for this <code>Recognizer</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#resume()">resume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resumes audio processing for this <code>Engine</code> by 
 entering the <code>RESUMED</code> state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/speech/recognition/Recognizer.html#setResultMask(int)">setResultMask</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mask to filter <code>ResultEvent</code>s for
 added <code>ResultListener</code>s.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_Engine"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface <A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/speech/Engine.html#getAudioManager()">getAudioManager</A>, <A HREF="../../../javax/speech/Engine.html#getEngineMask()">getEngineMask</A>, <A HREF="../../../javax/speech/Engine.html#getEngineMode()">getEngineMode</A>, <A HREF="../../../javax/speech/Engine.html#getEngineState()">getEngineState</A>, <A HREF="../../../javax/speech/Engine.html#getSpeechEventExecutor()">getSpeechEventExecutor</A>, <A HREF="../../../javax/speech/Engine.html#getVocabularyManager()">getVocabularyManager</A>, <A HREF="../../../javax/speech/Engine.html#setEngineMask(int)">setEngineMask</A>, <A HREF="../../../javax/speech/Engine.html#setSpeechEventExecutor(javax.speech.SpeechEventExecutor)">setSpeechEventExecutor</A>, <A HREF="../../../javax/speech/Engine.html#testEngineState(long)">testEngineState</A>, <A HREF="../../../javax/speech/Engine.html#waitEngineState(long)">waitEngineState</A>, <A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)">waitEngineState</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BUFFER_MODE"><!-- --></A><H3>
BUFFER_MODE</H3>
<PRE>
static final int <B>BUFFER_MODE</B></PRE>
<DL>
<DD>Flag used to indicate that audio buffering 
 should continue while <code>PAUSED</code>.

 <p>
 The description of the <A HREF="../../../javax/speech/recognition/Recognizer.html#pause(int)"><CODE>pause(int)</CODE></A> method
 includes more detail.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#pause(int)"><CODE>pause(int)</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../constant-values.html#javax.speech.recognition.Recognizer.BUFFER_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LISTENING"><!-- --></A><H3>
LISTENING</H3>
<PRE>
static final long <B>LISTENING</B></PRE>
<DL>
<DD>Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is listening to incoming audio for speech that may match an active
 <code>Grammar</code>.

 <p>
 A <code>RECOGNIZER_LISTENING</code> event is issued to indicate 
 a transition into the <code>LISTENING</code> substate of 
 the <code>RESUMED</code> state.
 <p>
 A <code>RECOGNIZER_PROCESSING</code> event is issued to indicate 
 a transition out of the <code>LISTENING</code> substate and
 into the <code>PROCESSING</code> substate.
 <p>
 An <code>ENGINE_PAUSED</code> event is issued to indicate a transition out
 of the <code>LISTENING</code> substate and into the <code>PAUSED</code> state.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#RESUMED"><CODE>RESUMED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING"><CODE>PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#RECOGNIZER_LISTENING"><CODE>RECOGNIZER_LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#RECOGNIZER_PROCESSING"><CODE>RECOGNIZER_PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_PAUSED"><CODE>ENGINE_PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A>, 
<A HREF="../../../constant-values.html#javax.speech.recognition.Recognizer.LISTENING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PROCESSING"><!-- --></A><H3>
PROCESSING</H3>
<PRE>
static final long <B>PROCESSING</B></PRE>
<DL>
<DD>Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is producing a <code>Result</code> for incoming speech that may match
 an active <code>Grammar</code>.

 <p>
 A <code>RECOGNIZER_PROCESSING</code> event is issued to indicate
 a transition into the <code>PROCESSING</code> substate
 from the <code>LISTENING</code> substate 
 when the start of a new <code>Result</code> is detected.
 <p>
 An <code>ENGINE_PAUSED</code> event is issued to indicate 
 a transition out of the <code>PROCESSING</code> substate and 
 into the <code>PAUSED</code> state when recognition
 of a <code>Result</code> is completed.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>Engine.PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#RECOGNIZER_PROCESSING"><CODE>RECOGNIZER_PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_PAUSED"><CODE>ENGINE_PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Result.html" title="interface in javax.speech.recognition"><CODE>Result</CODE></A>, 
<A HREF="../../../constant-values.html#javax.speech.recognition.Recognizer.PROCESSING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUFFERING"><!-- --></A><H3>
BUFFERING</H3>
<PRE>
static final long <B>BUFFERING</B></PRE>
<DL>
<DD>Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is buffering audio.

 It is normal for a <code>Recognizer</code> to buffer a limited amount of 
 audio so that it can later process the audio without missing speech.

 <p>
 A <code>Recognizer</code> is first allocated 
 in the <code>NOT_BUFFERING</code> state.
 A call to <code>resume</code> results in a transition 
 from the <code>NOT_BUFFERING</code> to the <code>BUFFERING</code> state
 if not already there.
 <p>
 A <code>Recognizer</code> will leave the <code>BUFFERING</code> state 
 if buffer overflow occurs.
 Recovery is described in the three states
 <code>PAUSED</code>, <code>LISTENING</code>, and <code>PROCESSING</code>.
 <p>
 An application can also leave the <code>BUFFERING</code> state
 by calling <code>pause()</code>.
 In this case, buffering resumes by calling <code>resume</code>.
 <p>
 A <code>RECOGNIZER_BUFFERING</code> event is issued to indicate
 a transition into 
 the <code>BUFFERING</code> state from the <code>NOT_BUFFERING</code> state.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#NOT_BUFFERING"><CODE>NOT_BUFFERING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING"><CODE>PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#RECOGNIZER_BUFFERING"><CODE>RECOGNIZER_BUFFERING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A>, 
<A HREF="../../../constant-values.html#javax.speech.recognition.Recognizer.BUFFERING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NOT_BUFFERING"><!-- --></A><H3>
NOT_BUFFERING</H3>
<PRE>
static final long <B>NOT_BUFFERING</B></PRE>
<DL>
<DD>Bit of state that is set when an <code>ALLOCATED</code> <code>Recognizer</code>
 is not buffering audio.

 It is normal for a Recognizer to buffer a limited amount of audio so
 that it can later process the audio without missing speech.

 <p>
 A <code>Recognizer</code> is first allocated 
 in the <code>NOT_BUFFERING</code> state.
 A call to <code>resume</code> results in a transition 
 from the <code>NOT_BUFFERING</code> to the <code>BUFFERING</code> state 
 if not already there.
 <p>
 A <code>Recognizer</code> will enter the <code>NOT_BUFFERING</code> state
 if buffer overflow occurs.
 Recovery is described in the three states 
 <code>PAUSED</code>, <code>LISTENING</code>, and <code>PROCESSING</code>.
 <p>
 An application can also enter the <code>NOT_BUFFERING</code> state 
 by calling <code>pause</code>.
 In this case, buffering resumes by calling <code>resume</code>.
 <p>
 A <code>RECOGNIZER_NOT_BUFFERING</code> event is issued to indicate
 a transition into
 the <code>NOT_BUFFERING</code> state from the <code>BUFFERING</code> state.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#BUFFERING"><CODE>BUFFERING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING"><CODE>PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#RECOGNIZER_NOT_BUFFERING"><CODE>RECOGNIZER_NOT_BUFFERING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A>, 
<A HREF="../../../constant-values.html#javax.speech.recognition.Recognizer.NOT_BUFFERING">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addRecognizerListener(javax.speech.recognition.RecognizerListener)"><!-- --></A><H3>
addRecognizerListener</H3>
<PRE>
void <B>addRecognizerListener</B>(<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition">RecognizerListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Requests notifications of <code>RecognizerEvent</code>s related to
 this <code>Recognizer</code>.

 An application can attach multiple <code>RecognizerListener</code>s to 
 this <code>Recognizer</code>.
 A single <code>RecognizerListener</code> can be attached to
 multiple <code>Recognizer</code>s.
 A <code>RecognizerListener</code> is removed with the
 <code>removeRecognizerListener</code> method.
 <p>
 A <code>RecognizerListener</code> can be attached or removed in 
 any <code>Recognizer</code> state.
 Individual <code>RecognizerEvent</code>s may be filtered with
 <code>setEngineMask</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the <code>RecognizerListener</code> to attach to 
        this <code>Recognizer</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/RecognizerEvent.html" title="class in javax.speech.recognition"><CODE>RecognizerEvent</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition"><CODE>RecognizerListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#removeRecognizerListener(javax.speech.recognition.RecognizerListener)"><CODE>removeRecognizerListener</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#setEngineMask(int)"><CODE>setEngineMask</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addResultListener(javax.speech.recognition.ResultListener)"><!-- --></A><H3>
addResultListener</H3>
<PRE>
void <B>addResultListener</B>(<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition">ResultListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Requests notifications of all <code>ResultEvent</code>s for all
 <code>Result</code>s produced by this <code>Recognizer</code>.

 <p>
 An application can attach multiple <code>ResultListener</code>s to
 this <code>Recognizer</code>.
 A single <code>ResultListener</code> can be attached to
 multiple <code>Recognizer</code>s.
 A <code>ResultListener</code> is removed with the 
 <code>removeResultListener</code> method.
 <p>
 <code>ResultListener</code>s attached to a <code>Recognizer</code> are 
 the only <code>ResultListener</code>s to receive the 
 <code>RESULT_CREATED</code> event in addition to 
 all subsequent <code>ResultEvent</code>s.
 <p>
 <code>ResultListener</code> objects can also be attached to 
 any <code>Grammar</code> or to any <code>Result</code>. 
 The <code>addResultListener</code> methods for the respective classes
 describe <code>ResultEvent</code>s received.
 <p>
 A <code>ResultListener</code> can be attached or removed in 
 any <code>Recognizer</code> state.
 Individual <code>ResultEvent</code>s may be filtered with
 <code>setResultMask</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the <code>ResultListener</code> to attach to
        this <code>Recognizer</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Result.html" title="interface in javax.speech.recognition"><CODE>Result</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Grammar.html#addResultListener(javax.speech.recognition.ResultListener)"><CODE>Grammar.addResultListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Result.html#addResultListener(javax.speech.recognition.ResultListener)"><CODE>Result.addResultListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#removeResultListener(javax.speech.recognition.ResultListener)"><CODE>removeResultListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultEvent.html" title="class in javax.speech.recognition"><CODE>ResultEvent</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultEvent.html#RESULT_CREATED"><CODE>RESULT_CREATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#setResultMask(int)"><CODE>setResultMask</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getResultMask()"><!-- --></A><H3>
getResultMask</H3>
<PRE>
int <B>getResultMask</B>()</PRE>
<DL>
<DD>Gets the mask to filter <code>ResultEvent</code>s for added <code>ResultListener</code>s.
 <p>
 See <code>setResultMask</code> for details.
 <p>
 The event mask can be set and retrieved in any <code>Recognizer</code> state.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current mask for <code>ResultEvent</code>s<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/ResultEvent.html" title="class in javax.speech.recognition"><CODE>ResultEvent</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition"><CODE>ResultListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#setResultMask(int)"><CODE>setResultMask</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setResultMask(int)"><!-- --></A><H3>
setResultMask</H3>
<PRE>
void <B>setResultMask</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Sets the mask to filter <code>ResultEvent</code>s for
 added <code>ResultListener</code>s.
 <p>
 It can improve efficiency to mask events that are not used.
 Events of interest can be seen by using the logical OR of the
 event constants defined in the <code>ResultEvent</code> class.
 <code>ResultEvent.DEFAULT_MASK</code> is the initial value.
 <p>
 The event mask can be set and retrieved in any <code>Recognizer</code> state.
 This method affects filtering of all attached <code>ResultListener</code>s.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - the mask for <code>ResultEvent</code>s<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/ResultEvent.html" title="class in javax.speech.recognition"><CODE>ResultEvent</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultEvent.html#DEFAULT_MASK"><CODE>ResultEvent.DEFAULT_MASK</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition"><CODE>ResultListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#getResultMask()"><CODE>getResultMask</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGrammarManager()"><!-- --></A><H3>
getGrammarManager</H3>
<PRE>
<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition">GrammarManager</A> <B>getGrammarManager</B>()</PRE>
<DL>
<DD>Gets the <code>GrammarManager</code> for this <code>Recognizer</code>.
 
 This method never returns <code>null</code>.
 It may be called in any state of a <code>Recognizer</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>GrammarManager</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RuleGrammar.html" title="interface in javax.speech.recognition"><CODE>RuleGrammar</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRecognizerProperties()"><!-- --></A><H3>
getRecognizerProperties</H3>
<PRE>
<A HREF="../../../javax/speech/recognition/RecognizerProperties.html" title="interface in javax.speech.recognition">RecognizerProperties</A> <B>getRecognizerProperties</B>()</PRE>
<DL>
<DD>Returns the properties for this <code>Recognizer</code>.
 <p>
 The <code>RecognizerProperties</code> are available 
 in any state of this <code>Recognizer</code>.
 However, changes only take effect once a <code>Recognizer</code> reaches
 the <code>ALLOCATED</code> state.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>RecognizerProperties</code> object for
         this <code>Recognizer</code></DL>
</DD>
</DL>
<HR>

<A NAME="getSpeakerManager()"><!-- --></A><H3>
getSpeakerManager</H3>
<PRE>
<A HREF="../../../javax/speech/recognition/SpeakerManager.html" title="interface in javax.speech.recognition">SpeakerManager</A> <B>getSpeakerManager</B>()
                                 throws <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></PRE>
<DL>
<DD>Returns the <code>SpeakerManager</code> for this <code>Recognizer</code>.

 This method may return <code>null</code> if this <code>Recognizer</code>
 does not store speaker data as indicated
 as indicated by <code>getSpeakerProfiles</code>.
 A speaker-independent <code>Recognizer</code>, for example, handles
 all speakers the same.
 <p>
 This method may be called in any state of a <code>Recognizer</code>.
 <p>
 The <code>SpeakerManager</code> methods 
 <code>listKnownSpeakers</code> and <code>setCurrentSpeaker</code>
 operate in any <code>Recognizer</code> state but only take effect in the
 <code>ALLOCATED</code> state. 
 This allows an application to set the initial <code>SpeakerProfile</code>
 prior to calling <code>allocate</code> for this <code>Recognizer</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the <code>SpeakerManager</code> for this <code>Recognizer</code>
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></CODE> - if the application does not have permission<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#allocate()"><CODE>allocate</CODE></A>, 
<A HREF="../../../javax/speech/recognition/SpeakerManager.html" title="interface in javax.speech.recognition"><CODE>SpeakerManager</CODE></A>, 
<A HREF="../../../javax/speech/recognition/SpeakerManager.html#listKnownSpeakers()"><CODE>listKnownSpeakers</CODE></A>, 
<A HREF="../../../javax/speech/recognition/SpeakerManager.html#setCurrentSpeaker(javax.speech.recognition.SpeakerProfile)"><CODE>setCurrentSpeaker</CODE></A>, 
<A HREF="../../../javax/speech/recognition/SpeakerProfile.html" title="class in javax.speech.recognition"><CODE>SpeakerProfile</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerMode.html#getSpeakerProfiles()"><CODE>getSpeakerProfiles</CODE></A><DT><B>Required permission:</B></DT>
  <DD><a href="../../../jsr113_security.html#SecurityConcerns"><code>javax.speech.recognition.SpeakerManager</code></a></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="processGrammars()"><!-- --></A><H3>
processGrammars</H3>
<PRE>
void <B>processGrammars</B>()
                     throws <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Informs this <code>Recognizer</code> that <code>Grammar</code>s have changed.

 The <code>GrammarManager</code> describes ways in which <code>Grammar</code>s 
 may change.
 <p>
 Calling this method is not required.
 Any <code>Grammar</code> updates are atomically committed with
 <code>resume</code>.
 <p>
 This method may be helpful for applications that call <code>pause</code> and
 anticipate some time between the time <code>Grammar</code>s are ready and
 the next call to <code>resume</code>.
 Any problems with <code>Grammar</code>s are reported with <code>resume</code>.
 <p>
 Calling this method does not result in any state changes or events.
 <p>
 It is not an error to call <code>processGrammars</code> when
 no <code>Grammar</code>s have been changed.
 It is not an error to call <code>processGrammars</code> multiple times.
 <p>
 The <code>processGrammars</code> method operates as defined when the 
 <code>Recognizer</code> is in the <code>ALLOCATED</code> and <code>PAUSED</code> states.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - if this <code>Recognizer</code> is 
         not <code>ALLOCATED</code> and <code>PAUSED</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition"><CODE>GrammarManager</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>Engine.ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>Engine.PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="releaseFocus()"><!-- --></A><H3>
releaseFocus</H3>
<PRE>
void <B>releaseFocus</B>()
                  throws <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Releases the recognition focus from this <code>Recognizer</code>.

 This request is made asynchronously.
 An <code>ENGINE_DEFOCUSED</code> event is issued to attached 
 <code>RecognizerListener</code>s once the focus
 is released and the <code>Recognizer</code> state changes
 from <code>FOCUSED</code> to <code>DEFOCUSED</code>.
 <p>
 Since focus is a key factor in the activation policy 
 for <code>Grammar</code>s, an <code>ENGINE_DEFOCUSED</code> event is followed by
 a <code>GRAMMAR_DEACTIVATED</code> event to the <code>GrammarListener</code>s of
 each <code>Grammar</code> that loses activation.
 The <code>Grammar</code> interface details the role of
 focus and <code>Grammar</code>
 <a href="Grammar.html#Section-GrammarActivation">activation conditions</a>.
 <p>
 Since only one application may have recognition focus at any time,
 applications should release focus whenever it is not required.
 Focus is discussed in more detail with
 <a href="#Section-focus_policy">Recognizer focus states</a>.
 <p>
 It is not an error for an application to release focus for 
 a <code>Recognizer</code> that does not have focus.
 <p>
 Focus is implicitly released after calling <code>deallocate</code>.
 <p>
 This method operates as defined when the standard
 <a href="#Section-Conditions_for_Operation">Conditions for Operation</a>
 apply.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - when not in the standard Conditions for Operation<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#requestFocus()"><CODE>requestFocus</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()"><CODE>deallocate</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#FOCUSED"><CODE>FOCUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEFOCUSED"><CODE>DEFOCUSED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEFOCUSED"><CODE>ENGINE_DEFOCUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarEvent.html#GRAMMAR_DEACTIVATED"><CODE>GRAMMAR_DEACTIVATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeRecognizerListener(javax.speech.recognition.RecognizerListener)"><!-- --></A><H3>
removeRecognizerListener</H3>
<PRE>
void <B>removeRecognizerListener</B>(<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition">RecognizerListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Removes a <code>RecognizerListener</code> from this <code>Recognizer</code>.

 <p>
 A <code>RecognizerListener</code> can be removed 
 in any state of a <code>Recognizer</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the RecognizerListener to be removed<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#addRecognizerListener(javax.speech.recognition.RecognizerListener)"><CODE>addRecognizerListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeResultListener(javax.speech.recognition.ResultListener)"><!-- --></A><H3>
removeResultListener</H3>
<PRE>
void <B>removeResultListener</B>(<A HREF="../../../javax/speech/recognition/ResultListener.html" title="interface in javax.speech.recognition">ResultListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Removes a <code>ResultListener</code> from this <code>Recognizer</code>.

 <p>
 A <code>ResultListener</code> can be attached or removed 
 in any state of a <code>Recognizer</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the <code>ResultListener</code> to be removed<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#addResultListener(javax.speech.recognition.ResultListener)"><CODE>addResultListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestFocus()"><!-- --></A><H3>
requestFocus</H3>
<PRE>
void <B>requestFocus</B>()
                  throws <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Requests the recognition focus for this <code>Recognizer</code>.

 This request is made asynchronously.
 When the focus is received, an <code>ENGINE_FOCUSED</code> event is issued to
 attached <code>RecognizerListener</code>s and the <code>Recognizer</code> 
 changes state from <code>DEFOCUSED</code> to <code>FOCUSED</code>.
 <p>
 Since focus is a key factor in the activation policy 
 for <code>Grammar</code>s, an <code>ENGINE_FOCUSED</code> event is followed by
 a <code>GRAMMAR_ACTIVATED</code> event to the <code>GrammarListener</code>s of
 each <code>Grammar</code> that is activated.
 The <code>Grammar</code> interface details the role of 
 focus and <code>Grammar</code>
 <a href="Grammar.html#Section-GrammarActivation">activation conditions</a>.
 <p>
 Since only one application may have recognition focus at any time,
 applications should only request focus when confident that the user
 is speaking to that application.
 Focus is discussed in more detail with
 <a href="#Section-focus_policy">Recognizer focus states</a>.
 <p>
 It is not an error for an application to request focus for
 a <code>Recognizer</code> that already has focus.
 <p>
 Focus is implicitly released after calling <code>deallocate</code>.
 <p>
 This method operates as defined when the standard
 <a href="#Section-Conditions_for_Operation">Conditions for Operation</a>
 apply.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - when not in the standard Conditions for Operation<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#releaseFocus()"><CODE>releaseFocus</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()"><CODE>deallocate()</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#FOCUSED"><CODE>FOCUSED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_FOCUSED"><CODE>ENGINE_FOCUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarEvent.html#GRAMMAR_ACTIVATED"><CODE>GRAMMAR_ACTIVATED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Grammar.html" title="interface in javax.speech.recognition"><CODE>Grammar</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="allocate()"><!-- --></A><H3>
allocate</H3>
<PRE>
void <B>allocate</B>()
              throws <A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A>,
                     <A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A>,
                     <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A>,
                     <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></PRE>
<DL>
<DD>Allocates the resources required for this <code>Engine</code> and puts it into
 the <code>ALLOCATED</code> state.

 When this method returns successfully
 the <code>ALLOCATED</code> bit of <code>Engine</code> state is set,
 and the <code>testEngineState(Engine.ALLOCATED)</code> method
 returns <code>true</code>.
 During the processing of the method,
 the <code>Engine</code> is temporarily in the <code>ALLOCATING_RESOURCES</code> 
 state.
 <p>
 While this method is being processed,
 events are issued to any <code>EngineListener</code>s
 attached to the <code>Engine</code> to indicate state changes
 (see <code>setEngineMask</code> for event filtering).
 First, as the <code>Engine</code> changes from the <code>DEALLOCATED</code> to
 the <code>ALLOCATING_RESOURCES</code> state,
 an <code>ENGINE_ALLOCATING_RESOURCES</code> event is issued.
 As the allocation process completes, the <code>Engine</code> moves from the
 <code>ALLOCATING_RESOURCES</code> state to the <code>ALLOCATED</code> state and
 an <code>ENGINE_ALLOCATED</code> event is issued.
 <p>
 The allocate method should be called for an <code>Engine</code> in
 the <code>DEALLOCATED</code> state.
 The method has no effect for an Engine in either
 the <code>ALLOCATING_RESOURCES</code> or <code>ALLOCATED</code> states.
 The method throws an exception in the <code>DEALLOCATING_RESOURCES</code>
 state.
 <p>
 If any problems are encountered during the allocation process so that
 the <code>Engine</code> cannot be allocated, the <code>Engine</code> returns to
 the <code>DEALLOCATED</code> state
 (with an <code>ENGINE_DEALLOCATED</code> event), 
 and an <code>EngineException</code> is thrown.
 <p>
 Allocating the resources for an <code>Engine</code> may be fast 
 (less than a second)
 or slow (several 10s of seconds) depending upon a range of factors.
 Since the <code>allocate</code> method does not return 
 until allocation is completed,
 applications may use <code>allocate(int)</code> with
 a flag for asynchronous operation
 <p>
 When the <code>Engine</code> reaches the <code>ALLOCATED</code> state,
 other <code>Engine</code> substates are determined according to the type of 
 <code>Engine</code>.
 Each <code>Engine</code> subclass provides more detail.

 <p>
 <code>Recognizer</code>s throw <code>SecurityException</code>
 if the application does not have permission.

 
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#allocate()">allocate</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A></CODE> - if any audio request fails
<DD><CODE><A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A></CODE> - if an allocation error occurred or the
         <code>Engine</code> is not operational.
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - if called for an <code>Engine</code> in the
         <code>DEALLOCATING_RESOURCES</code> state
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></CODE> - if the application does not have permission
         for this <code>Engine</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#allocate(int)"><CODE>allocate(int)</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()"><CODE>deallocate()</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ALLOCATING_RESOURCES"><CODE>ALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATED"><CODE>DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html" title="class in javax.speech"><CODE>EngineEvent</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_ALLOCATED"><CODE>ENGINE_ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATED"><CODE>ENGINE_DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#setEngineMask(int)"><CODE>setEngineMask</CODE></A><DT><B>Required permission:</B></DT>
  <DD><a href="../../../jsr113_security.html#SecurityConcerns"><code>javax.speech.recognition.Recognizer.allocate</code></a></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="allocate(int)"><!-- --></A><H3>
allocate</H3>
<PRE>
void <B>allocate</B>(int&nbsp;mode)
              throws <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A>,
                     <A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A>,
                     <A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A>,
                     <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A>,
                     <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></PRE>
<DL>
<DD>Allocates the resources required for this <code>Engine</code>
 using the <code>mode</code> specified
 and puts it into the <code>ALLOCATED</code> state.

 <p>
 When the <code>mode</code> is <code>ASYNCHRONOUS_MODE</code>, this method
 asynchronously allocates an <code>Engine</code>.
 In this case, the <code>Engine</code> transitions to 
 <code>ALLOCATING_RESOURCES</code> before this method returns.
 <p>
 When <code>mode</code> is <code>0</code>, this method operates the same
 as <code>allocate()</code>.
 <p>
 <a name="example-asynchronous-engine"></a>
 <code>waitEngineState</code> may be used to wait for the
 <code>ALLOCATED</code> state.
 <blockquote><code><pre>
 Engine engine;

 engine = EngineManager.createEngine(RecognizerMode.DEFAULT);
 engine.allocate(Engine.ASYNCHRONOUS_MODE);
 // Do other stuff while allocation takes place
 ...
 // Now wait until allocation is complete
 engine.waitEngineState(Engine.ALLOCATED);
 </pre></code></blockquote>

 <p>
 <code>Recognizer</code>s throw <code>SecurityException</code>
 if the application does not have permission.

 
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#allocate(int)">allocate</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - flag indicating the operational mode
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if called with an unexpected <code>mode</code> value
<DD><CODE><A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A></CODE> - if any audio access fails
<DD><CODE><A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A></CODE> - if an allocation error occurred or
         the <code>Engine</code> is not operational.
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - if called for an <code>Engine</code> in
         the <code>DEALLOCATING_RESOURCES</code> state
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/SecurityException.html?is-external=true" title="class or interface in java.lang">SecurityException</A></CODE> - if the application does not have permission
         for this <code>Engine</code><DT><B>See Also:</B><DD><A HREF="../../../javax/speech/Engine.html#ASYNCHRONOUS_MODE"><CODE>ASYNCHRONOUS_MODE</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#allocate()"><CODE>allocate()</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()"><CODE>deallocate()</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ALLOCATED"><CODE>ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ALLOCATING_RESOURCES"><CODE>ALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATED"><CODE>DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html" title="class in javax.speech"><CODE>EngineEvent</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_ALLOCATED"><CODE>ENGINE_ALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATED"><CODE>ENGINE_DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#setEngineMask(int)"><CODE>setEngineMask</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A><DT><B>Required permission:</B></DT>
  <DD><a href="../../../jsr113_security.html#SecurityConcerns"><code>javax.speech.recognition.Recognizer.allocate</code></a></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="deallocate()"><!-- --></A><H3>
deallocate</H3>
<PRE>
void <B>deallocate</B>()
                throws <A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A>,
                       <A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A>,
                       <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Deallocates the resources acquired for this <code>Engine</code>
 and returns it to the <code>DEALLOCATED</code> state.

 When this method returns the <code>DEALLOCATED</code> bit of <code>Engine</code> state is set
 so the <code>testEngineState(Engine.DEALLOCATED)</code> method returns <code>true</code>.
 During the processing of the method, the <code>Engine</code> is temporarily
 in the <code>DEALLOCATING_RESOURCES</code> state.
 <p>
 A <code>DEALLOCATED</code> <code>Engine</code> can be restarted with a subsequent
 call to <code>allocate</code>.
 <p>
 <code>Engine</code>s should normally clean up current activities
 before becoming <code>DEALLOCATED</code>.
 If needed, <code>deallocate</code> will wait for pending operations to complete
 appropriate for the type of <code>Engine</code>.
 The <code>deallocate(int)</code> method includes a flag
 to stop pending operations immediately.
 <p>
 Deallocating resources for an <code>Engine</code> is not always immediate.
 Use the <code>deallocate(int)</code> method with a flag
 for asynchronous operation.
 The documentation for the <code>allocate(int)</code>
 method shows an example of asynchronous operation
 <p>
 While this method is being processed, events are issued to any
 <code>EngineListener</code>s attached to the <code>Engine</code> to indicate state changes.
 First, as the <code>Engine</code> changes from the <code>ALLOCATED</code> to the
 <code>DEALLOCATING_RESOURCES</code> state,
 an <code>ENGINE_DEALLOCATING_RESOURCES</code> event is issued.
 As the deallocation process completes, the <code>Engine</code> moves from the
 <code>DEALLOCATING_RESOURCES</code> state to the <code>DEALLOCATED</code> state and an
 <code>ENGINE_DEALLOCATED</code> event is issued.
 <p>
 The <code>deallocate</code> method should only be called for
 an <code>Engine</code> in the <code>ALLOCATED</code> state.
 The method has no effect for an <code>Engine</code> in
 either the <code>DEALLOCATING_RESOURCES</code>
 or <code>DEALLOCATED</code> states.
 The method throws an exception in the <code>ALLOCATING_RESOURCES</code> state.

 <p>
 

 
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#deallocate()">deallocate</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A></CODE> - if any audio request fails
<DD><CODE><A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A></CODE> - if a deallocation error occurs
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - if called for an <code>Engine</code> in
         the <code>ALLOCATING_RESOURCES</code> state<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate(int)"><CODE>deallocate(int)</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#allocate()"><CODE>allocate()</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#allocate(int)"><CODE>allocate(int)</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ASYNCHRONOUS_MODE"><CODE>ASYNCHRONOUS_MODE</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#IMMEDIATE_MODE"><CODE>IMMEDIATE_MODE</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATED"><CODE>DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATING_RESOURCES"><CODE>DEALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html" title="class in javax.speech"><CODE>EngineEvent</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATING_RESOURCES"><CODE>ENGINE_DEALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATED"><CODE>ENGINE_DEALLOCATED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deallocate(int)"><!-- --></A><H3>
deallocate</H3>
<PRE>
void <B>deallocate</B>(int&nbsp;mode)
                throws <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A>,
                       <A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A>,
                       <A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A>,
                       <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Deallocates the resources acquired for this <code>Engine</code>
 using the <code>mode</code> specified
 and returns it to the <code>DEALLOCATED</code> state.

 <p>
 When using <code>ASYNCHRONOUS_MODE</code>, this method asynchronously
 deallocates an <code>Engine</code>.
 In this case, the <code>Engine</code> transitions to 
 <code>DEALLOCATING_RESOURCES</code> before this method returns.
 <p>
 When using <code>IMMEDIATE_MODE</code>, this method causes the <code>Engine</code>
 to stop pending operations immediately before beginning the
 deallocation process.
 <p>
 The <code>mode</code> values may be combined.
 Calling <code>deallocate(ASYNCHRONOUS_MODE | IMMEDIATE_MODE)</code>
 combines the behavior of both <code>mode</code>s.
 <p>
 When <code>mode</code> is <code>0</code>, this method operates the same
 as <code>deallocate()</code>.

 <p>
 

 
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#deallocate(int)">deallocate</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - flag indicating the operational mode
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if called with an unexpected <code>mode</code> value
<DD><CODE><A HREF="../../../javax/speech/AudioException.html" title="class in javax.speech">AudioException</A></CODE> - if any audio request fails
<DD><CODE><A HREF="../../../javax/speech/EngineException.html" title="class in javax.speech">EngineException</A></CODE> - if a deallocation error occurs
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - if called for an <code>Engine</code> in the
         <code>ALLOCATING_RESOURCES</code> state<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#deallocate()"><CODE>deallocate()</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#allocate()"><CODE>allocate()</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#ASYNCHRONOUS_MODE"><CODE>ASYNCHRONOUS_MODE</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#IMMEDIATE_MODE"><CODE>IMMEDIATE_MODE</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATED"><CODE>DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#DEALLOCATING_RESOURCES"><CODE>DEALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html" title="class in javax.speech"><CODE>EngineEvent</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATING_RESOURCES"><CODE>ENGINE_DEALLOCATING_RESOURCES</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_DEALLOCATED"><CODE>ENGINE_DEALLOCATED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#waitEngineState(long, long)"><CODE>waitEngineState</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="pause()"><!-- --></A><H3>
pause</H3>
<PRE>
void <B>pause</B>()
           throws <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Pauses the audio processing for this <code>Engine</code> and
 puts it into the <code>PAUSED</code> state.

 Pausing an <code>Engine</code> pauses the <code>Engine</code> instance and
 does not affect other <code>Engine</code> instances 
 in the current application or other applications,
 even though they may use the same underlying resources.
 <p>
 Applications may <code>pause</code> an <code>Engine</code> indefinitely.
 When an <code>Engine</code> moves from the <code>RESUMED</code> state
 to the <code>PAUSED</code> state,
 an <code>ENGINE_PAUSED</code> event is issued
 to each <code>EngineListener</code> attached to the <code>Engine</code>.
 The <code>PAUSED</code> bit of the <code>Engine</code> state
 is set to <code>true</code> when paused,
 and can be tested by the <code>getEngineState</code> method and
 other <code>Engine</code> state methods.
 <p>
 The <code>PAUSED</code> state is a substate of the <code>ALLOCATED</code> state.
 An <code>ALLOCATED</code> <code>Engine</code> is always in either 
 the <code>PAUSED</code> or the <code>RESUMED</code> state.
 <p>
 It is not an exception to <code>pause</code> an <code>Engine</code>
 that is already <code>PAUSED</code>.
 <p>
 The <code>pause</code> method does not always return immediately.
 Some applications may want to execute <code>pause</code> in 
 a separate <code>Thread</code>.
 <p>
 Note that calls to <code>pause</code> and <code>resume</code> nest,
 so that there must be a <code>resume</code> for each <code>pause</code>
 in order for <code>resume</code> to operate as described.
 <p>
 This method operates as defined when the standard
 <a href="#Section-Conditions_for_Operation">Conditions for Operation</a>
 apply.
 <p>
 Operational detail depends on the particular <code>Engine</code> subinterface.
 For <code>Engine</code>s that produce audio,
 pausing is analogous to pressing the "pause" button on
 a tape or CD player -
 audio output is paused and any unplayed audio is heard
 after <code>resume</code>.
 For <code>Engine</code>s that consume audio,
 pausing is analogous to pressing a "mute" button on
 a microphone -
 by default, audio input is ignored and permanently lost.
 Audio processing does not begin again until after <code>resume</code>.
 
 <p>
 For a <code>Recognizer</code>,
 pausing stops processing of the audio input stream as close
 as possible to the time of the call to <code>pause</code>.
 By default, anything a user says while the <code>Recognizer</code> is
 <code>PAUSED</code> will not be heard by the <code>Recognizer</code>.
 <p>
 The <A HREF="../../../javax/speech/recognition/Recognizer.html#pause(int)"><CODE>pause(int)</CODE></A> method provides
 more detail and options.
 This method is equivalent to <code>pause(0)</code>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#pause()">pause</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - when not in the standard Conditions for Operation<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#pause(int)"><CODE>pause(int)</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#RESUMED"><CODE>RESUMED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_PAUSED"><CODE>ENGINE_PAUSED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="pause(int)"><!-- --></A><H3>
pause</H3>
<PRE>
void <B>pause</B>(int&nbsp;mode)
           throws <A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A>,
                  <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Pauses a <code>Recognizer</code> with additional options.

 The <A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause()</CODE></A> method describes the basic functionality.

 <p>
 For a <code>Recognizer</code>,
 pausing stops processing of the audio input stream as close
 as possible to the time of the call to <code>pause</code>.
 Pausing a <code>Recognizer</code> allows an application to 
 modify <code>Grammar</code>s and update activation.
 <p>
 By default (<code>BUFFER_MODE</code> not set), anything a user says while the
 <code>Recognizer</code> is paused will not be heard by the <code>Recognizer</code>.
 The <code>BUFFER_MODE</code> flag indicates that the <code>Recognizer</code>
 should buffer audio while <code>PAUSED</code> so that no audio will be lost
 once it returns to the <code>LISTENING</code> substate.
 <p>
 Pausing a <code>Recognizer</code> during the middle of user speech
 forces the <code>Recognizer</code>
 to finalize processing of that incoming speech -
 a recognition <code>Result</code> cannot cross
 a <code>pause</code>/<code>resume</code> boundary.
 Most <code>Recognizer</code>s have some amount of internal audio buffering.
 This means that some <code>Recognizer</code> processing may continue after
 the call to <code>pause</code>.
 For example, <code>Result</code>s can be created and finalized.
 The <code>IMMEDIATE_MODE</code> flag indicates that 
 pending recognition buffers should be cleared instead of processed.
 <p>
 A <code>Recognizer</code> returns to the <code>RESUMED</code> state
 (and <code>LISTENING</code> substate) with a call to <code>resume</code>.
 However, calls to <code>pause</code> and <code>resume</code> nest, 
 so that there must be a <code>resume</code> for each <code>pause</code>.
 This avoids <code>Grammar</code> update issues for multithreaded applications.
 <p>
 This method operates as defined when the standard
 <a href="#Section-Conditions_for_Operation">Conditions for Operation</a>
 apply.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - modifier flags to use with this method
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/javame/reference/apis/jsr118/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - when called with an unexpected <code>mode</code> value
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - when not in the standard Conditions for Operation<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause()</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#BUFFER_MODE"><CODE>BUFFER_MODE</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#IMMEDIATE_MODE"><CODE>IMMEDIATE_MODE</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#resume()"><CODE>resume</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#RESUMED"><CODE>RESUMED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_PAUSED"><CODE>ENGINE_PAUSED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resume()"><!-- --></A><H3>
resume</H3>
<PRE>
boolean <B>resume</B>()
               throws <A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></PRE>
<DL>
<DD>Resumes audio processing for this <code>Engine</code> by 
 entering the <code>RESUMED</code> state.

 Resuming an <code>Engine</code> instance does not
 affect other <code>Engine</code> instances
 that share the same underlying resources.
 <p>
 The <code>pause</code> method describes how to pause an <code>Engine</code>.
 <p>
 Note that calls to <code>pause</code> and <code>resume</code> nest,
 so that there must be a <code>resume</code> for each <code>pause</code>
 in order for this method to operate as described.
 <p>
 When an <code>Engine</code> moves from the <code>PAUSED</code> state 
 to the <code>RESUMED</code> state,
 an <code>ENGINE_RESUMED</code> event is issued to each <code>EngineListener</code>
 attached to the <code>Engine</code>.
 The <code>RESUMED</code> bit of the <code>Engine</code> state is set
 when the <code>Engine</code> resumes,
 and can be tested by the <code>getEngineState</code> method and
 other <code>Engine</code> state methods.
 <p>
 The <code>RESUMED</code> state is a substate of the <code>ALLOCATED</code> state.
 An <code>ALLOCATED</code> Engine is always in either
 the <code>PAUSED</code> or the <code>RESUMED</code> state.
 <p>
 It is not an exception to <code>resume</code> an <code>Engine</code> that
 is already in the <code>RESUMED</code> state.
 <p>
 The <code>resume</code> method does not always return immediately.
 Some applications may want to execute <code>resume</code>
 in a separate <code>Thread</code>.
 The documentation for the <code>Thread</code> class shows examples of this.
 <p>
 This method operates as defined when the standard
 <a href="#Section-Conditions_for_Operation">Conditions for Operation</a>
 apply.

 <p>
 For a <code>Recognizer</code>,
 this method resumes processing the audio input stream as close
 as possible to the time of the call to <code>resume</code>.
 Recognition can only occur after calling <code>resume</code>.
 <!--
 Additionally, Recognizers that support background adaptation
 may adapt to background noise while RESUMED.
 -->
 <p>
 When this method causes the <code>Recognizer</code> 
 to enter the <code>RESUMED</code> state,
 any <code>Grammar</code> updates are atomically committed
 (see <a href="Grammar.html#Section-commit">Committing Changes</a>).
 It checks that all the loaded <code>Grammar</code>s are ready to use. 
 Any problems with the current definition
 of any <code>RuleGrammar</code> result in a <code>CHANGES_REJECTED</code> event. 
 Problems might include an undefined <code>RuleReference</code>, 
 illegal recursion and so on
 (see the <a href="http://www.w3.org/TR/speech-grammar/" target="_blank">
  SRGS definition</a> for details).
 <p>
 <code>Grammar</code> updates are committed asynchronously 
 (the changes have not necessarily been committed when the call returns).
 When the changes have been committed,
 a <code>CHANGES_COMMITTED</code> or <code>CHANGES_REJECTED</code> event is issued
 to all <code>RecognizerListener</code>s attached to this <code>Recognizer</code>.
 Corresponding to these events,
 <code>GrammarListener</code>s for any changed <code>Grammar</code>s receive either
 a <code>GRAMMAR_CHANGES_COMMITTED</code> or <code>GRAMMAR_CHANGES_REJECTED</code>
 event.
 <p>
 Note that calling <code>pause</code> before <code>resume</code> is important to
 avoid <code>Grammar</code> update issues that can occur with
 <code>ResultEvent</code>s and in multithreaded applications.
 <p>
 After any <code>Grammar</code> updates, 
 the <code>Recognizer</code> enters the <code>RESUMED</code> state.
 It waits in the <code>LISTENING</code> substate until speech is found.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../javax/speech/Engine.html#resume()">resume</A></CODE> in interface <CODE><A HREF="../../../javax/speech/Engine.html" title="interface in javax.speech">Engine</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the <code>Engine</code> is in or is about to enter
 the <code>RESUMED</code> state; or <code>false</code> if it will remain
 <code>PAUSED</code> due to nested calls to <code>pause</code>.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/speech/EngineStateException.html" title="class in javax.speech">EngineStateException</A></CODE> - when not in the standard Conditions for Operation<DT><B>See Also:</B><DD><A HREF="../../../javax/speech/recognition/Recognizer.html#pause()"><CODE>pause</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#PAUSED"><CODE>PAUSED</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#RESUMED"><CODE>RESUMED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#LISTENING"><CODE>LISTENING</CODE></A>, 
<A HREF="../../../javax/speech/recognition/Recognizer.html#PROCESSING"><CODE>PROCESSING</CODE></A>, 
<A HREF="../../../javax/speech/Engine.html#getEngineState()"><CODE>getEngineState</CODE></A>, 
<A HREF="../../../javax/speech/EngineEvent.html#ENGINE_RESUMED"><CODE>ENGINE_RESUMED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#CHANGES_COMMITTED"><CODE>CHANGES_COMMITTED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerEvent.html#CHANGES_REJECTED"><CODE>CHANGES_REJECTED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarEvent.html#GRAMMAR_CHANGES_COMMITTED"><CODE>GRAMMAR_CHANGES_COMMITTED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarEvent.html#GRAMMAR_CHANGES_REJECTED"><CODE>GRAMMAR_CHANGES_REJECTED</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RuleGrammar.html" title="interface in javax.speech.recognition"><CODE>RuleGrammar</CODE></A>, 
<A HREF="../../../javax/speech/recognition/RecognizerListener.html" title="interface in javax.speech.recognition"><CODE>RecognizerListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/GrammarListener.html" title="interface in javax.speech.recognition"><CODE>GrammarListener</CODE></A>, 
<A HREF="../../../javax/speech/recognition/ResultEvent.html" title="class in javax.speech.recognition"><CODE>ResultEvent</CODE></A><DT><B>Required Features:</B></DT>
  <DD><A HREF="../../../javax/speech/EngineMode.html#getSupportsLetterToSound()"><CODE>getSupportsLetterToSound</CODE></A>
 when the vocabulary specified is not known,
 results in a <code>CHANGES_REJECTED</code> event otherwise</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Recognizer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>JSAPI 2.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/speech/recognition/GrammarManager.html" title="interface in javax.speech.recognition"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/speech/recognition/RecognizerEvent.html" title="class in javax.speech.recognition"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/speech/recognition/Recognizer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Recognizer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

                <p align=center><font size=-1>
                Java<sup>TM</sup> Speech API 2.0,
                Final Release v2.0.6.<br>
                &copy; 2008, Conversay and Sun Microsystems.
                </font></p>
            
</BODY>
</HTML>
